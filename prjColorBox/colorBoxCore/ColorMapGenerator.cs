using System;
using System.Collections.Generic;
using System.Linq;

namespace prjColorBox
{
    public class ColorMapGenerator
    {
        // Создаем один экземпляр Random для всего класса, чтобы избежать проблем с одинаковыми seed,
        // если бы Random создавался в методе GenerateMap каждый раз.
        private Random _random = new Random();

        // Основной метод для создания карты цветов.
        // rows: количество строк на карте.
        // cols: количество столбцов на карте.
        // numColors: сколько различных цветов должно быть на карте.
        public MapData GenerateMap(int rows, int cols, int numColors)
        {
            // ---- Начальные проверки входных параметров ----
            if (numColors <= 0) // Количество цветов не может быть нулевым или отрицательным.
                throw new ArgumentOutOfRangeException(nameof(numColors), "Количество цветов должно быть положительным.");
            if (rows <= 0 || cols <= 0) // Размеры карты также должны быть положительными.
                throw new ArgumentOutOfRangeException("Количество строк и столбцов должно быть положительным.");

            // Общее количество ячеек на карте.
            int totalCells = rows * cols;

            // ---- Шаг 1: Генерация УНИКАЛЬНЫХ количеств для каждого цвета ----
            // Цель: каждый цвет должен встречаться на карте РАЗНОЕ количество раз.

            // Список для хранения количеств каждого из 'numColors' цветов.
            List<int> counts = new List<int>();
            // Переменная для подсчета минимально необходимого количества ячеек,
            // чтобы разместить 'numColors' цветов с минимально возможными уникальными количествами (1, 2, 3, ...).
            long minSumRequired = 0; // Используем long на случай большого numColors, чтобы избежать переполнения при суммировании.

            // Инициализируем 'counts' минимально возможными уникальными значениями.
            // Например, для 3 цветов это будет [1, 2, 3].
            for (int i = 0; i < numColors; i++)
            {
                counts.Add(i + 1); // Первый цвет будет иметь как минимум 1 ячейку, второй - 2, и т.д.
                minSumRequired += (i + 1); // Суммируем эти минимальные количества.
            }

            // Проверяем, достаточно ли ячеек на карте для размещения цветов с такими минимальными уникальными количествами.
            if (minSumRequired > totalCells)
                throw new ArgumentException($"Невозможно разместить {numColors} цветов с различным количеством в {totalCells} ячейках. Минимально требуемое количество ячеек: {minSumRequired}. Попробуйте меньше цветов или большую карту.");

            // ---- Шаг 2: Распределение оставшихся ячеек ----
            // У нас есть 'minSumRequired' ячеек, уже "зарезервированных" под минимальные уникальные количества.
            // Оставшиеся ячейки 'totalCells - minSumRequired' нужно распределить между цветами так,
            // чтобы их количества остались уникальными. Самый простой способ - добавлять по одной ячейке
            // к случайным цветам. Так как мы начали с уже уникальных количеств (1, 2, 3,...),
            // добавление к любому из них сохранит уникальность относительно других (если мы не добавляем столько,
            // что одно количество догонит другое и они не были изначально соседними, но наш метод распределения этого избегает).
            int remainingCellsToDistribute = totalCells - (int)minSumRequired;
            for (int i = 0; i < remainingCellsToDistribute; i++)
            {
                // Увеличиваем количество для случайно выбранного цвета.
                // Индекс от 0 до numColors-1 соответствует элементам в списке 'counts'.
                counts[_random.Next(numColors)]++;
            }
            // После этого цикла сумма всех элементов в 'counts' будет равна 'totalCells',
            // и все значения в 'counts' будут по-прежнему различны, так как мы начали с уникальных
            // и лишь увеличивали их.

            // ---- Шаг 3: Сопоставление сгенерированных количеств с идентификаторами цветов ----
            // Создаем словарь, где ключ - это ID цвета (например, 1, 2, 3...), а значение - его количество.
            var colorIdToCountMap = new Dictionary<int, int>();
            // Генерируем список ID цветов (от 1 до numColors).
            List<int> colorIds = Enumerable.Range(1, numColors).ToList();

            // Перемешиваем список 'counts'. Это делается для того, чтобы конкретное количество
            // (например, самое большое) не всегда доставалось цвету с ID 1 (или любому другому фиксированному ID).
            // Это добавляет случайности в то, какой именно цвет будет самым частым.
            counts = counts.OrderBy(c => _random.Next()).ToList();

            // Заполняем словарь: каждому ID цвета из 'colorIds' присваиваем количество из 'counts'.
            for (int i = 0; i < numColors; i++)
            {
                colorIdToCountMap.Add(colorIds[i], counts[i]);
            }

            // ---- Шаг 4: Заполнение сетки (карты) цветами ----
            // 1. Создаем список всех возможных координат (r, c) на сетке.
            List<(int r, int c)> allPositions = new List<(int r, int c)>();
            for (int r = 0; r < rows; r++)
            {
                for (int c = 0; c < cols; c++)
                {
                    allPositions.Add((r, c));
                }
            }

            // 2. Перемешиваем этот список позиций. Это гарантирует, что цвета будут распределены
            // по карте случайным образом, а не, например, все ячейки одного цвета подряд.
            allPositions = allPositions.OrderBy(pos => _random.Next()).ToList();

            // 3. Создаем саму сетку (массив массивов целых чисел).
            int[][] grid = new int[rows][];
            for (int r = 0; r < rows; r++)
            {
                // Инициализируем каждый ряд сетки. Ячейки по умолчанию будут иметь значение 0.
                grid[r] = new int[cols];
            }

            // Индекс для прохода по перемешанному списку позиций 'allPositions'.
            int positionIndex = 0;
            // Проходим по нашему словарю "ID цвета -> его количество".
            foreach (var kvp in colorIdToCountMap)
            {
                int colorId = kvp.Key; // Текущий ID цвета.
                int countForThisColor = kvp.Value; // Сколько ячеек должно быть заполнено этим цветом.

                // Заполняем 'countForThisColor' ячеек на карте текущим 'colorId'.
                for (int i = 0; i < countForThisColor; i++)
                {
                    // Проверяем, не вышли ли мы за пределы доступных позиций.
                    // Этого не должно случиться, если все расчеты выше верны
                    // (т.е. сумма всех количеств равна общему числу ячеек).
                    if (positionIndex < allPositions.Count)
                    {
                        // Берем следующую случайную позицию из списка.
                        var (r, c) = allPositions[positionIndex++];
                        // Помещаем ID цвета в эту ячейку на сетке.
                        grid[r][c] = colorId;
                    }
                    else
                    {
                        // Если это произошло, значит, где-то ошибка в логике подсчета ячеек или распределения.
                        throw new InvalidOperationException("Несоответствие между общим количеством цветов для размещения и общим числом доступных ячеек.");
                    }
                }
            }

            // Создаем и возвращаем объект MapData, который содержит сгенерированную сетку
            // и информацию о количестве каждого цвета.
            return new MapData(grid, colorIdToCountMap);
        }
    }
}